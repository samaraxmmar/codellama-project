import * as vscode from 'vscode';
import axios from 'axios';

// URL of the CodeLlama model API (adapt according to your deployment)
const CODELLAMA_API_URL = 'http://localhost:8000/generate';

export function activate(context: vscode.ExtensionContext) {
    console.log('CodeLlama Assistant Extension activated');

    // Command to generate code
    let generateCodeCommand = vscode.commands.registerCommand('codellama-assistant.generateCode', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage('No active editor found');
            return;
        }

        // Get selected text or current line
        const selection = editor.selection;
        const prompt = editor.document.getText(selection) || editor.document.lineAt(editor.selection.active.line).text;

        if (!prompt.trim()) {
            vscode.window.showErrorMessage('Please select text or place the cursor on a line with content');
            return;
        }

        try {
            vscode.window.showInformationMessage('Generating code...');
            
            const response = await axios.post(CODELLAMA_API_URL, {
                prompt: prompt,
                max_length: 150,
                temperature: 0.7
            });

            const generatedCode = response.data.generated_text;
            
            // Insert the generated code at the cursor position
            editor.edit(editBuilder => {
                editBuilder.insert(editor.selection.end, '\n' + generatedCode);
            });

            vscode.window.showInformationMessage('Code generated successfully!');
        } catch (error) {
            vscode.window.showErrorMessage(`Error during generation: ${error}`);
        }
    });

    // Command to complete code
    let completeCodeCommand = vscode.commands.registerCommand('codellama-assistant.completeCode', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor) {
            vscode.window.showErrorMessage('No active editor found');
            return;
        }

        const position = editor.selection.active;
        const lineText = editor.document.lineAt(position.line).text;
        const textBeforeCursor = lineText.substring(0, position.character);

        if (!textBeforeCursor.trim()) {
            vscode.window.showErrorMessage('No context found for completion');
            return;
        }

        try {
            vscode.window.showInformationMessage('Completing code...');
            
            const response = await axios.post(CODELLAMA_API_URL, {
                prompt: textBeforeCursor,
                max_length: 100,
                temperature: 0.3
            });

            const completion = response.data.generated_text;
            
            // Insert the completion at the cursor position
            editor.edit(editBuilder => {
                editBuilder.insert(position, completion);
            });

            vscode.window.showInformationMessage('Completion successful!');
        } catch (error) {
            vscode.window.showErrorMessage(`Error during completion: ${error}`);
        }
    });

    // Auto-completion provider
    const completionProvider = vscode.languages.registerCompletionItemProvider(
        ['javascript', 'python', 'typescript', 'java', 'cpp'],
        {
            async provideCompletionItems(document: vscode.TextDocument, position: vscode.Position) {
                const linePrefix = document.lineAt(position).text.substr(0, position.character);
                
                if (linePrefix.length < 3) {
                    return undefined;
                }

                try {
                    const response = await axios.post(CODELLAMA_API_URL, {
                        prompt: linePrefix,
                        max_length: 50,
                        temperature: 0.2
                    });

                    const suggestion = response.data.generated_text;
                    const completionItem = new vscode.CompletionItem(suggestion, vscode.CompletionItemKind.Text);
                    completionItem.detail = 'CodeLlama Assistant';
                    completionItem.documentation = 'Suggestion generated by CodeLlama';
                    
                    return [completionItem];
                } catch (error) {
                    console.error('Error during auto-completion:', error);
                    return undefined;
                }
            }
        },
        '.' // Trigger completion after a dot
    );

    context.subscriptions.push(generateCodeCommand, completeCodeCommand, completionProvider);
}

export function deactivate() {
    console.log('CodeLlama Assistant Extension deactivated');
}

